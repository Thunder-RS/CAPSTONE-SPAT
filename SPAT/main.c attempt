#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/sensor.h>
#include <zephyr/logging/log.h>
#include <modem/lte_lc.h>
#include <zephyr/net/socket.h>
#include <net/nrf_cloud.h>
#include <net/nrf_cloud_agnss.h>
#include <modem/nrf_modem_lib.h>
#include <modem/modem_info.h>
#include <nrf_modem_gnss.h>
#include <dk_buttons_and_leds.h>
#include <cJSON.h>

LOG_MODULE_REGISTER(sensor_gnss_cloud, CONFIG_LOG_DEFAULT_LEVEL);
K_SEM_DEFINE(lte_connected, 0, 1);
K_SEM_DEFINE(gnss_done, 0, 1); // Signals GNSS attempt completion

/* Sensor devices */
const struct device *bme280 = DEVICE_DT_GET_ANY(bosch_bme280);
const struct device *apds = DEVICE_DT_GET_ANY(avago_apds9960);

/* GNSS data */
static struct nrf_modem_gnss_pvt_data_frame pvt_data;
static struct nrf_modem_gnss_agnss_data_frame agnss_request;
static int64_t gnss_start_time;
static bool gnss_active = false;
static bool has_fix = false;
static int num_satellites = 0;
#define GNSS_TIMEOUT_MS (5 * 60 * 1000) // 5 minutes
#define SLEEP_DURATION_MS (20 * 60 * 1000) // 20 minutes

/* nRF Cloud device ID */
static char device_id[NRF_CLOUD_CLIENT_ID_MAX_LEN + 1];

static void print_fix_data(struct nrf_modem_gnss_pvt_data_frame *pvt_data)
{
    LOG_INF("Latitude:  %.6f", pvt_data->latitude);
    LOG_INF("Longitude: %.6f", pvt_data->longitude);
    LOG_INF("Altitude:  %.1f m", (double)pvt_data->altitude);
    LOG_INF("Time (UTC): %02d:%02d:%02d.%03d",
            pvt_data->datetime.hour, pvt_data->datetime.minute,
            pvt_data->datetime.seconds, pvt_data->datetime.ms);
}

static void enter_sleep_mode(void)
{
    int err;

    LOG_INF("Entering sleep mode");
    dk_set_led_off(DK_LED1); // Turn off LED to save power

    // Stop GNSS
    if (gnss_active) {
        err = nrf_modem_gnss_stop();
        if (err) {
            LOG_ERR("Failed to stop GNSS, err %d", err);
        } else {
            gnss_active = false;
        }
    }

    // Deactivate GNSS functional mode
    err = lte_lc_func_mode_set(LTE_LC_FUNC_MODE_DEACTIVATE_GNSS);
    if (err) {
        LOG_ERR("Failed to deactivate GNSS, err %d", err);
    }

    // Disconnect from nRF Cloud to save power
    err = nrf_cloud_disconnect();
    if (err) {
        LOG_ERR("Failed to disconnect nRF Cloud, err %d", err);
    }

    // Enter sleep
    LOG_INF("Sleeping for %d minutes", SLEEP_DURATION_MS / 60000);
    k_msleep(SLEEP_DURATION_MS);
}

static int read_sensors(struct sensor_value *temp, struct sensor_value *hum, struct sensor_value *light)
{
    int err, retries = 3;
    while (retries--) {
        err = sensor_sample_fetch(bme280);
        if (!err) break;
        LOG_ERR("BME280 fetch failed: %d, retries left: %d", err, retries);
        k_sleep(K_MSEC₁00));
    }
    if (err) return err;

    err = sensor_channel_get(bme280, SENSOR_CHAN_AMBIENT_TEMP, temp);
    if (err) {
        LOG_ERR("BME280 temp get failed: %d", err);
        return err;
    }
    err = sensor_channel_get(bme280, SENSOR_CHAN_HUMIDITY, hum);
    if (err) {
        LOG_ERR("BME280 humidity get failed: %d", err);
        return err;
    }

    err = sensor_sample_fetch(apds);
    if (err) {
        LOG_ERR("APDS9960 fetch failed: %d", err);
        return err;
    }
    err = sensor_channel_get(apds, SENSOR_CHAN_LIGHT, light);
    if (err) {
        LOG_ERR("APDS9960 light get failed: %d", err);
        return err;
    }
    return 0;
}

static int send_data_to_cloud(struct sensor_value *temp, struct sensor_value *hum, struct sensor_value *light)
{
    int ret;
    cJSON *root;
    char *json_str;

    // Temperature
    root = cJSON_CreateObject();
    if (!root) {
        LOG_ERR("Failed to create JSON object");
        return -ENOMEM;
    }
    cJSON_AddStringToObject(root, "appId", "TEMP");
    cJSON_AddNumberToObject(root, "data", sensor_value_to_double(temp));
    cJSON_AddStringToObject(root, "messageType", "DATA");
    
    json_str = cJSON_PrintUnformatted(root);
    if (!json_str) {
        LOG_ERR("Failed to create JSON string");
        cJSON_Delete(root);
        return -ENOMEM;
    }
    struct nrf_cloud_tx_data temp_msg = {
        .data.ptr = json_str, .data.len = strlen(json_str),
        .qos = MQTT_QOS_1_AT_LEAST_ONCE, .topic_type = NRF_CLOUD_TOPIC_MESSAGE
    };
    LOG_INF("Sending temp: %s (value: %f)", json_str, sensor_value_to_double(temp));
    ret = nrf_cloud_send(&temp_msg);
    cJSON_free(json_str);
    cJSON_Delete(root);
    if (ret) {
        LOG_ERR("Failed to send temperature data: %d", ret);
        return ret;
    }

    // Humidity
    root = cJSON_CreateObject();
    if (!root) {
        LOG_ERR("Failed to create JSON object");
        return -ENOMEM;
    }
    cJSON_AddStringToObject(root, "appId", "HUMID");
    cJSON_AddNumberToObject(root, "data", sensor_value_to_double(hum));
    cJSON_AddStringToObject(root, "messageType", "DATA");
    json_str = cJSON_PrintUnformatted(root);
    if (!json_str) {
        LOG_ERR("Failed to create JSON string");
        cJSON_Delete(root);
        return -ENOMEM;
    }
    struct nrf_cloud_tx_data hum_msg = {
        .data.ptr = json_str, .data.len = strlen(json_str),
        .qos = MQTT_QOS_1_AT_LEAST_ONCE, .topic_type = NRF_CLOUD_TOPIC_MESSAGE
    };
    LOG_INF("Sending humid: %s", json_str);
    ret = nrf_cloud_send(&hum_msg);
    cJSON_free(json_str);
    cJSON_Delete(root);
    if (ret) {
        LOG_ERR("Failed to send humidity data: %d", ret);
        return ret;
    }

    // Light
    root = cJSON_CreateObject();
    if (!root) {
        LOG_ERR("Failed to create JSON object");
        return -ENOMEM;
    }
    cJSON_AddStringToObject(root, "appId", "LIGHT");
    cJSON_AddNumberToObject(root, "data", sensor_value_to_double(light));
    cJSON_AddStringToObject(root, "messageType", "DATA");
    json_str = cJSON_PrintUnformatted(root);
    if (!json_str) {
        LOG_ERR("Failed to create JSON string");
        cJSON_Delete(root);
        return -ENOMEM;
    }
    struct nrf_cloud_tx_data light_msg = {
        .data.ptr = json_str, .data.len = strlen(json_str),
        .qos = MQTT_QOS_1_AT_LEAST_ONCE, .topic_type = NRF_CLOUD_TOPIC_MESSAGE
    };
    LOG_INF("Sending light: %s", json_str);
    ret = nrf_cloud_send(&light_msg);
    cJSON_free(json_str);
    cJSON_Delete(root);
    if (ret) {
        LOG_ERR("Failed to send light data: %d", ret);
        return ret;
    }

    return 0;
}

static int send_gnss_to_cloud(void)
{
    int ret;
    cJSON *root;
    char *json_str;

    root = cJSON_CreateObject();
    if (!root) {
        LOG_ERR("Failed to create JSON object");
        return -ENOMEM;
    }
    cJSON_AddStringToObject(root, "appId", "GNSS");
    cJSON *data = cJSON_CreateObject();
    cJSON_AddBoolToObject(data, "fix_valid", has_fix);
    cJSON_AddNumberToObject(data, "num_satellites", num_satellites);
    if (has_fix) {
        cJSON_AddNumberToObject(data, "latitude", pvt_data.latitude);
        cJSON_AddNumberToObject(data, "longitude", pvt_data.longitude);
        cJSON_AddNumberToObject(data, "altitude", pvt_data.altitude);
        cJSON *time = cJSON_CreateObject();
        cJSON_AddNumberToObject(time, "hour", pvt_data.datetime.hour);
        cJSON_AddNumberToObject(time, "minute", pvt_data.datetime.minute);
        cJSON_AddNumberToObject(time, "seconds", pvt_data.datetime.seconds);
        cJSON_AddNumberToObject(time, "ms", pvt_data.datetime.ms);
        cJSON_AddItemToObject(root, "time", time);
    }
    cJSON_AddItemToObject(root, "data", data);
    cJSON_AddStringToObject(root, "messageType", "DATA");

    json_str = cJSON_PrintUnformatted(root);
    if (!json_str) {
        LOG_ERR("Failed to create JSON string");
        cJSON_Delete(root);
        return -ENOMEM;
    }
    struct nrf_cloud_tx_data gnss_msg = {
        .data.ptr = json_str, .data.len = strlen(json_str),
        .qos = MQTT_QOS_1_AT_LEAST_ONCE, .topic_type = NRF_CLOUD_TOPIC_MESSAGE
    };
    LOG_INF("Sending GNSS: %s", json_str);
    ret = nrf_cloud_send(&gnss_msg);
    cJSON_free(json_str);
    cJSON_Delete(root);
    if (ret) {
        LOG_ERR("Failed to send GNSS data: %d", ret);
    }

    return ret;
}

static void gnss_event_handler(int event)
{
    int err;

    // Check for GNSS timeout
    if (gnss_active && (k_uptime_get() - gnss_start_time) >= GNSS_TIMEOUT_MS) {
        LOG_INF("GNSS fix timeout after %d minutes", GNSS_TIMEOUT_MS / 60000);
        has_fix = false; // No fix obtained
        k_sem_give(gnss_done); // Signal main loop to proceed
        return;
    }

    switch (event) {
    case NRF_MODEM_GNSS_EVT_PVT:
        LOG_INF("Searching...");
        num_satellites = 0;
        for (int i = 0; i < 12; i++) {
            if (pvt_data.sv[i].signal != 0) {
                LOG_INF("sv: %d, cn0: %d, signal: %d, elev: %d, azim: %d",
                        pvt_data.sv[i].sv, pvt_data.sv[i].cn0, pvt_data.sv[i].signal,
                        pvt_data.sv[i].elevation, pvt_data.sv[i].azimuth);
                num_satellites++;
            }
        }
        LOG_INF("Number of current satellites: %d", num_satellites);
        err = nrf_modem_gnss_read(&pvt_data, sizeof(pvt_data), NRF_MODEM_GNSS_DATA_PVT);
        if (err) {
            LOG_ERR("nrf_modem_gnss_read failed, err %d", err);
            return;
        }
        LOG_INF("PVT flags: 0x%08x", pvt_data.flags);
        if (pvt_data.flags & NRF_MODEM_GNSS_PVT_FLAG_FIX_VALID) {
            dk_set_led_on(DK_LED1);
            print_fix_data(&pvt_data);
            has_fix = true;
            k_sem_give(gnss_done); // Signal main loop to proceed
        } else {
            LOG_INF("No valid fix");
        }
        break;

    case NRF_MODEM_GNSS_EVT_AGNSS_REQ:
        LOG_INF("A-GNSS data needed");
        err = nrf_modem_gnss_read(&agnss_request, sizeof(agnss_request), NRF_MODEM_GNSS_DATA_AGNSS_REQ);
        if (err) {
            LOG_ERR("Failed to read A-GNSS request, err %d", err);
            return;
        }
        err = nrf_cloud_agnss_request(&agnss_request);
        if (err) {
            LOG_ERR("Failed to request A-GNSS data, err %d", err);
            return;
        }
        LOG_INF("A-GNSS request sent to nRF Cloud");
        break;

    case NRF_MODEM_GNSS_EVT_FIX:
        LOG_INF("GNSS fix event received");
        break;

    default:
        LOG_INF("Unhandled GNSS event: %d", event);
        break;
    }
}

static void lte_handler(const struct lte_lc_evt *const evt)
{
    switch (evt->type) {
    case LTE_LC_EVT_NW_REG_STATUS:
        LOG_INF("Network registration status: %d", evt->nw_reg_status);
        if (evt->nw_reg_status == LTE_LC_NW_REG_REGISTERED_HOME ||
            evt->nw_reg_status == LTE_LC_NW_REG_REGISTERED_ROAMING) {
            LOG_INF("Connected to %s network",
                    evt->nw_reg_status == LTE_LC_NW_REG_REGISTERED_HOME ? "home" : "roaming");
            k_sem_give(lte_connected);
        } else if (evt->nw_reg_status == LTE_LC_NW_REG_NOT_REGISTERED ||
                   evt->nw_reg_status == LTE_LC_NW_REG_SEARCHING) {
            LOG_INF("Network not registered or searching...");
        } else {
            LOG_ERR("Unexpected registration status: %d", evt->nw_reg_status);
        }
        break;
    case LTE_LC_EVT_CELL_UPDATE:
        LOG_INF("Cell update: Cell ID %d", evt->cell.id);
        break;
    case LTE_LC_EVT_LTE_MODE_UPDATE:
        LOG_INF("LTE mode update: %d", evt->lte_mode);
        break;
    case LTE_LC_EVT_MODEM_EVENT:
        LOG_INF("Modem event: %d", evt->modem_evt);
        break;
    default:
        LOG_INF("Unhandled LTE event: %d", evt->type);
        break;
    }
}

static void cloud_event_handler(const struct nrf_cloud_evt *evt)
{
    if (evt == NULL) {
        LOG_ERR("Received NULL event");
        return;
    }
    switch (evt->type) {
    case NRF_CLOUD_EVT_TRANSPORT_CONNECTED:
        LOG_INF("Transport connected");
        break;
    case NRF_CLOUD_EVT_TRANSPORT_DISCONNECTED:
        LOG_INF("Transport disconnected");
        break;
    case NRF_CLOUD_EVT_READY:
        LOG_INF("Cloud connection ready");
        break;
    case NRF_CLOUD_EVT_ERROR:
        LOG_ERR("Cloud error occurred (type: %d)", evt->type);
        break;
    case NRF_CLOUD_EVT_RX_DATA_SHADOW:
        LOG_INF("Received shadow data");
        if (evt->data.ptr && evt->data.len > 0) {
            LOG_INF("Shadow content: %s", (const char *)evt->data.ptr);
        } else {
            LOG_INF("Shadow content: <empty>");
        }
        break;
    default:
        LOG_INF("Unhandled cloud event: %d", evt->type);
        break;
    }
}

static int init(void)
{
    int err;

    err = nrf_modem_lib_init();
    if (err) {
        LOG_ERR("Failed to initialize modem library: 0x%X", err);
        return -EFAULT;
    }

    err = modem_info_init();
    if (err) {
        LOG_ERR("Modem info initialization failed: %d", err);
        return err;
    }

    err = dk_leds_init();
    if (err) {
        LOG_ERR("Failed to initialize LEDs, err %d", err);
        return err;
    }

    LOG_INF("Modem and peripherals initialized");
    return 0;
}

static int connect_to_lte(void)
{
    int err;
    LOG_INF("Waiting for network...");

    k_sem_reset(lte_connected);
    err = lte_lc_connect_async(lte_handler);
    if (err) {
        LOG_ERR("Failed to init modem, error: %d", err);
        return err;
    }

    err = lte_lc_psm_req(true);
    if (err) {
        LOG_ERR("Failed to request PSM, err %d", err);
    }

    err = lte_lc_edrx_req(true);
    if (err) {
        LOG_ERR("Failed to request eDRX, err %d", err);
    }

    k_sem_take(lte_connected, K_FOREVER);
    LOG_INF("Connected to LTE");
    return 0;
}

static int setup_connection(void)
{
    int err;

    err = connect_to_lte();
    if (err) {
        LOG_ERR("Failed to connect to cellular network: %d", err);
        return err;
    }

    memset(device_id, 0, sizeof(device_id));
    err = nrf_cloud_client_id_get(device_id, sizeof(device_id));
    if (err) {
        LOG_ERR("Failed to get device ID, error: %d", err);
        return err;
    }
    LOG_INF("Device ID: %s (length: %d)", device_id, strlen(device_id));

    LOG_INF("Attempting initial nRF Cloud connection...");
    struct nrf_cloud_init_param params = {
        .client_id = device_id,
        .event_handler = cloud_event_handler,
    };

    err = nrf_cloud_init(¶ms);
    if (err) {
        LOG_ERR("Failed to initialize nRF Cloud library: %d", err);
        return err;
    }

    err = nrf_cloud_connect();
    if (err) {
        LOG_ERR("Initial nRF Cloud connection failed: %d", err);
        return err;
    }
    LOG_INF("Connected to nRF Cloud");
    return 0;
}

static int setup_gnss(void)
{
    int err;

    err = lte_lc_func_mode_set(LTE_LC_FUNC_MODE_ACTIVATE_GNSS);
    if (err) {
        LOG_ERR("Failed to activate GNSS, err %d", err);
        return err;
    }

    err = nrf_modem_gnss_event_handler_set(gnss_event_handler);
    if (err) {
        LOG_ERR("Failed to set GNSS event handler, err %d", err);
        return err;
    }

    err = nrf_modem_gnss_fix_interval_set(1);
    if (err) {
        LOG_ERR("Failed to set GNSS fix interval, err %d", err);
        return err;
    }

    err = nrf_modem_gnss_fix_retry_set(10);
    if (err) {
        LOG_ERR("Failed to set GNSS fix retry, err %d", err);
        return err;
    }

    err = nrf_modem_gnss_start();
    if (err) {
        LOG_ERR("Failed to start GNSS, err %d", err);
        return err;
    }

    gnss_start_time = k_uptime_get();
    gnss_active = true;
    LOG_INF("GNSS started");
    return 0;
}

static int attempt_gnss_fix(void)
{
    int err;

    k_sem_reset(gnss_done);
    err = setup_gnss();
    if (err) {
        LOG_ERR("Failed to set up GNSS, err %d", err);
        return err;
    }

    // Wait for GNSS fix or timeout
    k_sem_take(gnss_done, K_MSEC(GNSS_TIMEOUT_MS));
    LOG_INF("GNSS attempt completed (fix: %s)", has_fix ? "yes" : "no");

    // Stop GNSS to save power
    if (gnss_active) {
        err = nrf_modem_gnss_stop();
        if (err) {
            LOG_ERR("Failed to stop GNSS, err %d", err);
        } else {
            gnss_active = false;
        }
    }

    return 0;
}

static int setup(void)
{
    int err, retries = 3;

    err = init();
    if (err) {
        LOG_ERR("Initialization failed.");
        return err;
    }

    err = setup_connection();
    if (err) {
        LOG_ERR("Connection set-up failed.");
        return err;
    }

    while (retries--) {
        if (device_is_ready(bme280) && device_is_ready(apds)) {
            break;
        }
        LOG_ERR("Sensors not ready, retries left: %d", retries);
        k_sleep(K_MSEC(1000));
    }
    if (!device_is_ready(bme280)) {
        LOG_ERR("BME280 device is not ready, stopping");
        return -ENODEV;
    }
    if (!device_is_ready(apds)) {
        LOG_ERR("APDS9960 device is not ready, stopping");
        return -ENODEV;
    }
    return 0;
}

static bool cred_check(struct nrf_cloud_credentials_status *const cs)
{
    int ret;

    ret = nrf_cloud_credentials_check(cs);
    if (ret) {
        LOG_ERR("nRF Cloud credentials check failed, error: %d", ret);
        return false;
    }

    LOG_INF("Checking credentials in sec tag %u", cs->sec_tag);
    if (!cs->ca) {
        LOG_WRN("CA certificate missing");
    }
    if (!cs->prv_key) {
        LOG_WRN("Private key missing");
    }
    if (!cs->client_cert) {
        LOG_WRN("Client certificate missing");
    }

    return (cs->ca && cs->prv_key && cs->client_cert);
}

int main(void)
{
    int err;
    struct nrf_cloud_credentials_status cs = {0};
    struct sensor_value temp, hum, light;
    struct modem_param_info modem_info;

    LOG_INF("Starting nRF9161 Sensor and GNSS Cloud Application");

    err = setup();
    if (err) {
        LOG_ERR("Setup failed, stopping.");
        return err;
    }

    if (!cred_check(&cs)) {
        LOG_ERR("Credentials check failed, stopping.");
        return -EACCES;
    }

    while (1) {
        // Attempt GNSS fix
        err = attempt_gnss_fix();
        if (err) {
            LOG_ERR("GNSS attempt failed, continuing: %d", err);
        }

        // Get modem info
        err = modem_info_params_get(&modem_info);
        if (!err) {
            LOG_INF("Signal strength: %d dBm", modem_info.network.rsrp.value);
        } else {
            LOG_WRN("Failed to get modem info: %d (continuing)", err);
        }

        // Read and send sensor data
        if (read_sensors(&temp, &hum, &light) == 0) {
            LOG_INF("Temp: %d.%06d°C, Humidity: %d.%06d%%, Light: %d.%06d lux",
                    temp.val1, temp.val2, hum.val1, hum.val2, light.val1, light.val2);

            err = send_data_to_cloud(&temp, &hum, &light);
            if (err) {
                LOG_ERR("Sensor data send failed, attempting reconnect");
                nrf_cloud_disconnect();
                err = setup_connection();
                if (err) {
                    LOG_ERR("Reconnection failed, continuing: %d", err);
                }
            }
        } else {
            LOG_ERR("Sensor read failed");
        }

        // Send GNSS data (fix, partial, or none)
        err = send_gnss_to_cloud();
        if (err) {
            LOG_ERR("GNSS data send failed, attempting reconnect");
            nrf_cloud_disconnect();
            err = setup_connection();
            if (err) {
                LOG_ERR("Reconnection failed, continuing: %d", err);
            }
        }

        // Enter sleep mode
        enter_sleep_mode();

        // Reconnect to nRF Cloud after waking
        err = setup_connection();
        if (err) {
            LOG_ERR("Failed to reconnect after wake, continuing: %d", err);
        }
    }
    return 0;
}
